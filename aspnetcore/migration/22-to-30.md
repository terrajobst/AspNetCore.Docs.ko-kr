---
title: ASP.NET 코어 2.2에서 3.0으로 마이그레이션
author: rick-anderson
description: ASP.NET 코어 2.2 프로젝트를 ASP.NET 코어 3.0으로 마이그레이션하는 방법을 알아봅니다.
ms.author: riande
ms.custom: mvc
ms.date: 01/21/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 46223011e82c7115147f59ee03e20d8033103b98
ms.sourcegitcommit: f0aeeab6ab6e09db713bb9b7862c45f4d447771b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/08/2020
ms.locfileid: "80977238"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>ASP.NET 코어 2.2에서 3.0으로 마이그레이션

[스콧 애디와](https://github.com/scottaddie) [릭 앤더슨](https://twitter.com/RickAndMSFT)

이 문서에서는 기존 ASP.NET 코어 2.2 프로젝트를 ASP.NET 코어 3.0으로 업데이트하는 방법을 설명합니다.

## <a name="prerequisites"></a>사전 요구 사항

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Mac용 Visual Studio](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>global.json에서 .NET Core SDK 버전 업데이트

솔루션이 [global.json](/dotnet/core/tools/global-json) 파일을 사용하여 특정 .NET Core SDK 버전을 대상으로 `version` 하는 경우 해당 속성을 컴퓨터에 설치된 3.0 버전으로 업데이트합니다.

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>프로젝트 파일 업데이트

### <a name="update-the-target-framework"></a>대상 프레임워크 업데이트

ASP.NET 코어 3.0 이상은 .NET 코어에서만 실행됩니다. 대상 [프레임워크 모니커(TFM)를](/dotnet/standard/frameworks) `netcoreapp3.0`다음으로 설정합니다.

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>사용되지 않는 패키지 참조 제거

많은 수의 NuGet 패키지는 ASP.NET 코어 3.0에 대해 생산되지 않습니다. 이러한 패키지 참조는 프로젝트 파일에서 제거해야 합니다. ASP.NET 코어 2.2 웹 앱에 대한 다음 프로젝트 파일을 고려하십시오.

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

ASP.NET 코어 3.0에 대한 업데이트 된 프로젝트 파일 :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

업데이트 된 ASP.NET 코어 3.0 프로젝트 파일:

* `<PropertyGroup>`에서
  * TFM을 다음으로 업데이트합니다.`netcoreapp3.0`
  * 요소를 제거합니다. `<AspNetCoreHostingModel>` 자세한 내용은 이 문서의 [프로세스 내 호스팅 모델을](#in-process-hosting-model) 참조하십시오.

* `<ItemGroup>`에서
  * `Microsoft.AspNetCore.App`제거됩니다. 자세한 내용은 이 문서의 [프레임워크 참조를](#framework-reference) 참조하십시오.
  * `Microsoft.AspNetCore.Razor.Design`제거되고 다음 패키지 목록에서 더 이상 생산되지 않습니다.

더 이상 생산되지 않는 패키지의 전체 목록을 보려면 다음 확장 목록을 선택합니다.

<details>
    <summary>더 이상 생산되지 않는 패키지 목록을 확장하려면 클릭하십시오.</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>마이크로소프트.아스프넷코어.SignalR</li>
        <li>마이크로소프트.아스프넷코어. SignalR. 코어</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>주요 변경 사항 검토

[주요 변경 사항 검토](#break)

### <a name="framework-reference"></a>프레임워크 참조

위에 나열된 패키지 중 하나를 통해 사용할 수 있었던 ASP.NET Core의 기능은 `Microsoft.AspNetCore.App` 공유 프레임워크의 일부로 사용할 수 있습니다. *공유 프레임워크*는 머신에 설치된 어셈블리(*.dll* 파일) 세트이며 런타임 구성 요소 및 타기팅 팩을 포함합니다. 자세한 내용은 [공유 프레임워크](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/)를 참조하세요.

* `Microsoft.NET.Sdk.Web` SDK를 대상으로 하는 프로젝트는 `Microsoft.AspNetCore.App` 프레임워크를 암시적으로 참조합니다.

  이러한 프로젝트에는 추가 참조가 필요하지 않습니다.

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* `Microsoft.NET.Sdk` 대상 프로젝트 `Microsoft.NET.Sdk.Razor` 또는 SDK는 다음에 `Microsoft.AspNetCore.App`명시적을 `FrameworkReference` 추가해야 합니다.

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Docker를 사용하는 프레임워크 종속 빌드

ASP.NET Core [공유 프레임워크에](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) 종속된 패키지를 사용하는 콘솔 앱의 프레임워크 종속 빌드는 다음과 같은 런타임 오류를 제공할 수 있습니다.

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`는 ASP.NET 코어 런타임을 포함하는 공유 프레임워크이며 [도트넷/코어/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker 이미지에만 존재합니다. 3.0 SDK는 공유 프레임워크에서 사용할 수 있는 라이브러리의 복제본을 포함하지 않음으로써 ASP.NET Core를 사용하여 프레임워크 종속 빌드의 크기를 줄입니다. 이는 최대 18MB의 잠재적 절감 효과이지만 앱을 실행하려면 ASP.NET 코어 런타임이 존재/설치되어야 합니다.

앱에 ASP.NET Core 공유 프레임워크에 종속성(직접 또는 간접)이 있는지 확인하려면 앱의 빌드/게시 중에 생성된 *runtimeconfig.json* 파일을 검사합니다. 다음 JSON 파일은 ASP.NET Core 공유 프레임워크에 대한 종속성을 보여 주며 다음과 같은 것입니다.

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

앱에서 Docker를 사용하는 경우 ASP.NET 코어 3.0이 포함된 기본 이미지를 사용합니다. `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`)을 입력합니다.

### <a name="add-package-references-for-removed-assemblies"></a>제거된 어셈블리에 대한 패키지 참조 추가

ASP.NET Core 3.0은 이전에 패키지 참조의 `Microsoft.AspNetCore.App` 일부였던 일부 어셈블리를 제거합니다. 제거된 어셈블리를 시각화하려면 두 공유 프레임워크 폴더를 비교합니다. 예를 들어 버전 2.2.7과 3.0.0을 비교하면 다음과 같은

![공유 프레임워크 어셈블리 비교](22-to-30/_static/assembly-diff.png)

제거된 어셈블리에서 제공하는 피쳐를 계속 사용하려면 해당 패키지의 3.0 버전을 참조하십시오.

* **개별 사용자 계정이** 있는 템플릿 으로 생성된 웹 앱에는 다음 패키지를 추가해야 합니다.

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  데이터베이스 공급자별 패키지를 참조하는 방법에 대한 자세한 내용은 [데이터베이스 공급자](/ef/core/providers/index)를 참조하십시오.

* 아이덴티티 UI

  Id [UI에](xref:security/authentication/identity) 대한 지원은 [Microsoft.AspNetCore.Identity.UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) 패키지를 참조하여 추가할 수 있습니다.

* 스파 서비스

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [마이크로소프트.아스프넷코어.스파서비스.확장](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* 타사 &ndash; 인증 흐름에 대한 인증 지원은 NuGet 패키지로 사용할 수 있습니다.

  * 페이스북 오오스[(마이크로소프트.아스프넷코어.인증.페이스북)](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook)
  * 구글 오스[(마이크로 소프트.AspNetCore.인증.구글)](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google)
  * 마이크로소프트 계정 인증[(마이크로소프트.AspNetCore.Authentication.마이크로소프트 계정)](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount)
  * 오픈 ID 연결 인증[(마이크로소프트.AspNetCore.인증.오픈 아이드커넥트)](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect)
  * 오픈 ID 커넥트 베어러 토큰[(마이크로소프트.AspNetCore.인증.Jwt베어러)](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer)
  * 트위터 오오스[(마이크로소프트.AspNetCore.인증.트위터)](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter)
  * WsFederation 인증[(Microsoft.AspNetCore.인증.WsFederation)](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation)

* `System.Net.HttpClient` &ndash; [Microsoft.AspNet.WebApi.Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet 패키지에 대한 서식 지정 및 콘텐츠 `System.Net.HttpClient` 협상 지원은 `ReadAsAsync` 및 `PostJsonAsync`와 같은 API를 사용하여 유용한 확장성을 제공합니다.

* Razor 보기 및 &ndash; 페이지의 런타임 컴파일을 위한 Razor 런타임 컴파일 지원은 이제 [Microsoft.AspNetCore.Mvc.Razor.Razor.Runtime 컴파일의](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)일부입니다.

* MVC `Newtonsoft.Json` (Json.NET) &ndash; 와 MVC를 `Newtonsoft.Json` 사용하기위한 지원은 이제 [마이크로 소프트의 일부입니다.AspNetCore.Mvc.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>시작 변경 사항

다음 이미지는 ASP.NET 코어 2.2 Razor 페이지 웹 앱에서 삭제되고 변경된 줄을 보여 주며 다음과 같은 것을 보여 주며 다음과 같은 이미지를 보여줍니다.

![ASP.NET 코어 2.2 면도기 웹 앱에서 삭제되고 변경된 줄](22-to-30/_static/startup2.2.png)

이전 이미지에서 삭제된 코드는 빨간색으로 표시됩니다. 삭제된 코드에는 파일을 비교하기 전에 삭제된 쿠키 옵션 코드가 표시되지 않습니다.

다음 이미지는 코어 3.0 Razor 페이지 웹 앱의 ASP.NET 변경된 줄을 보여 주며 다음과 같은 것을 보여 주며 다음과 같은 것을 보여 주며, 다음과 같은 이미지입니다.

![ASP.NET 코어 3.0 면도기 웹 앱에서 추가 및 변경 된 라인](22-to-30/_static/startup3.0.png)

앞의 이미지에서 추가된 코드는 녹색으로 표시됩니다. 다음 변경 사항에 대한 자세한 내용은 다음을 참조하십시오.

* `services.AddMvc`을 `services.AddRazorPages` [참조하십시오.](#mvc-service-registration)
* `CompatibilityVersion`, <xref:mvc/compatibility-version>은을 참조하십시오.
* `IHostingEnvironment`을 `IWebHostEnvironment` [참조하십시오.](https://github.com/dotnet/AspNetCore/issues/7749)
* `app.UseAuthorization`주문 승인 미들웨어를 추가해야 함을 표시하기 위해 템플릿에 추가되었습니다. 앱에서 권한 부여를 사용하지 않는 경우 `app.UseAuthorization`에 대한 호출을 안전하게 제거할 수 있습니다.
* `app.UseEndpoints`에서는 [이](#razor-pages) 문서의 Razor 페이지 또는 [Startup.Configure를](#migrate-startupconfigure) 참조하십시오.

### <a name="analyzer-support"></a>분석기 지원

이전에 `Microsoft.NET.Sdk.Web` [Microsoft.AspNetCore.Mvc.Analyzeers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) 패키지의 일부로 제공된 암시적 참조 분석기를 대상으로 하는 프로젝트입니다. 이러한 참조를 활성화하기 위해 추가 참조가 필요하지 않습니다.

앱에서 이전에 [Microsoft.AspNetCore.Mvc.Api.Api.Analyzeers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) 패키지를 사용하여 제공된 [API 분석기를](xref:web-api/advanced/analyzers) 사용하는 경우 프로젝트 파일을 편집하여 .NET Core 웹 SDK의 일부로 제공된 분석기를 참조합니다.

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Razor 클래스 라이브러리

MVC에 UI 구성 요소를 제공하는 Razor `AddRazorSupportForMvc` 클래스 라이브러리 프로젝트는 프로젝트 파일에서 속성을 설정해야 합니다.

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>In-Process 호스팅 모델

프로젝트는 ASP.NET 코어 3.0 이상의 [프로세스 내 호스팅 모델로](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) 기본설정됩니다. 값이 있는 `<AspNetCoreHostingModel>` 경우 선택적으로 프로젝트 파일에서 속성을 `InProcess`제거할 수 있습니다.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>구성

`ConfigureWebHostDefaults` (Program.cs)에서 제공하는 웹 호스트 빌더로*Program.cs*Kestrel 구성을 마이그레이션합니다.

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

앱에서 `HostBuilder`"를 통해 호스트를 `UseKestrel` 수동으로 만드는 경우 `ConfigureWebHostDefaults`다음 의 웹 호스트 빌더에 대해 호출하십시오.

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>연결 미들웨어가 연결 어댑터를 대체합니다.

연결 어댑터 ()`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`케스트렐에서 제거되었습니다. 연결 어댑터를 연결 미들웨어로 교체합니다. 연결 미들웨어는 ASP.NET 코어 파이프라인의 HTTP 미들웨어와 유사하지만 하위 수준의 연결에 적합합니다. HTTPS 및 연결 로깅:

* 연결 어댑터에서 연결 미들웨어로 이동되었습니다.
* 이러한 확장 메서드는 이전 버전의 ASP.NET 코어에서와 같이 작동합니다. 

자세한 내용은 [Kestrel 문서의 ListenOptions.Protocols 섹션에서 TlsFilterConnectionHandler 예제를](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols)참조하십시오.

### <a name="transport-abstractions-moved-and-made-public"></a>전송 추상화가 이동하고 공개

Kestrel 전송 계층이 `Connections.Abstractions`에서 공용 인터페이스로 공개되었습니다. 이러한 업데이트의 일부로:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`및 관련 형식이 제거되었습니다.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>전송 옵션으로 <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> 이동했습니다.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`에서 제거되었습니다. <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>

자세한 내용은 다음 GitHub 리소스를 참조하십시오.

* [클라이언트/서버 네트워킹 추상화(닷컴/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [새로운 암반 청취자 추상화를 구현하고 상단에 다시 플랫 케스트렐 (닷넷 / AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>케스트렐 요청 트레일러 헤더

이전 버전의 ASP.NET 코어를 대상으로 하는 앱의 경우:

* Kestrel은 요청 헤더 컬렉션에 HTTP/1.1 청크 트레일러 헤더를 추가합니다.
* 트레일러는 요청 본문을 끝까지 읽은 후에 사용할 수 있습니다.

이로 인해 헤더와 트레일러 간의 모호성에 대한 우려가 있으므로 트레일러는 3.0에서`RequestTrailerExtensions`새 컬렉션() 으로 이동되었습니다.

HTTP/2 요청 트레일러는 다음과 같습니다.

* ASP.NET 코어 2.2에서는 사용할 수 없습니다.
* 3.0에서 `RequestTrailerExtensions`사용할 수 있습니다.

이러한 예고편에 액세스하기 위해 새 요청 확장 메서드가 있습니다. HTTP/1.1과 마찬가지로 요청 본문을 끝까지 읽은 후에 트레일러를 사용할 수 있습니다.

3.0 릴리스의 경우 `RequestTrailerExtensions` 다음 방법을 사용할 수 있습니다.

* `GetDeclaredTrailers`&ndash; 본문 `Trailer` 이후에 예상할 트레일러를 나열하는 요청 헤더를 가져옵니다.
* `SupportsTrailers`&ndash; 요청이 트레일러 헤더 수신을 지원하는지 나타냅니다.
* `CheckTrailersAvailable`&ndash; 요청이 트레일러를 지원하는지 그리고 트레일러를 읽을 수 있는지 확인합니다. 이 검사는 읽을 트레일러가 있다고 가정하지 않습니다. 이 메서드에서 반환되더라도 `true` 읽을 트레일러가 없을 수 있습니다.
* `GetTrailer`&ndash; 응답에서 요청된 후행 헤더를 가져옵니다. 호출하기 `SupportsTrailers` `GetTrailer`전에 확인하거나 요청이 후행 헤더를 지원하지 않는 경우 발생할 <xref:System.NotSupportedException> 수 있습니다.

자세한 내용은 [별도의 컬렉션에 요청 트레일러 넣기(닷트넷/AspNetCore #10410)를](https://github.com/dotnet/AspNetCore/pull/10410)참조하십시오.

### <a name="allowsynchronousio-disabled"></a>허용동기

`AllowSynchronousIO``HttpRequest.Body.Read` `HttpResponse.Body.Write`및. `Stream.Flush` 이러한 API는 앱 충돌로 이어지는 스레드 부족의 원인입니다. 3.0에서 `AllowSynchronousIO`는 기본적으로 사용하지 않도록 설정됩니다. 자세한 내용은 [Kestrel 문서의 동기 I/O 섹션을](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io)참조하십시오.

동기 I/O가 필요한 경우 사용 중인 서버에서 `AllowSynchronousIO` 옵션을 구성하여 활성화할 수 `ConfigureKestrel`있습니다(예: Kestrel을 사용하는 경우). 서버(케스트렐, HttpSys, TestServer 등)에는 모두 다른 `AllowSynchronousIO` 서버에 영향을 주지 않는 자체 옵션이 있습니다. 다음 옵션을 사용하여 요청별로 모든 서버에 대해 동기 I/O를 `IHttpBodyControlFeature.AllowSynchronousIO` 사용할 수 있습니다.

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

[Dispose에서](/dotnet/standard/garbage-collection/implementing-dispose)동기 <xref:System.IO.TextWriter> API를 호출하는 구현 또는 기타 스트림에 문제가 있는 <xref:System.IO.Stream.DisposeAsync*> 경우 대신 새 API를 호출합니다.

자세한 내용은 [모든 서버(닷트넷/AspNetCore #7644)에서 [공지] AllowSynchronousIO를 사용하지 않도록 설정합니다.](https://github.com/dotnet/AspNetCore/issues/7644)

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>마이크로소프트.AspNetCore.Server.Kestrel.Https 어셈블리 제거

ASP.NET 코어 2.1에서 *Microsoft.AspNetCore.Server.Kestrel.Https.dll의* 내용은 *Microsoft.AspNetCore.Server.Server.Kestrel.Core.dll로*이동되었습니다. 이 업데이트는 특성을 `TypeForwardedTo` 사용하여 중단되지 않은 업데이트입니다. 3.0의 경우 빈 *Microsoft.AspNetCore.Server.Kestrel.Https.dll* 어셈블리 및 NuGet 패키지가 제거되었습니다.

[Microsoft.AspNetCore.Server.Kestrel.https를](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) 참조하는 라이브러리는 ASP.NET 코어 종속성을 2.1 이상으로 업데이트해야 합니다.

코어 2.1 ASP.NET 대상으로 하는 앱 및 라이브러리는 [Microsoft.AspNetCore.Server.Server.Kestrel.Https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) 패키지에 대한 직접 참조를 제거해야 합니다.

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>뉴턴소프트.Json (Json.NET) 지원

ASP.NET 코어 공유 [프레임 워크를 개선하기위한](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)작업의 일환으로, [뉴턴 소프트 .Json (Json.NET)는](https://www.newtonsoft.com/json/help/html/Introduction.htm) ASP.NET 코어 공유 프레임 워크에서 제거되었습니다.

ASP.NET 코어에 대한 기본 JSON <xref:System.Text.Json>직렬화기는 .NET Core 3.0에서 새로 온 것입니다. 가능하면 `System.Text.Json` 사용하는 것이 좋습니다. 고성능이며 추가 라이브러리 종속성이 필요하지 않습니다. 그러나 새 `System.Text.Json` 기능이기 때문에 현재 앱에 필요한 기능이 누락되었을 수 있습니다. 자세한 내용은 [뉴턴소프트.Json에서 System.Text.Json으로 마이그레이션하는 방법을](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)참조하십시오.

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>ASP.NET 코어 3.0 SignalR 프로젝트에서 뉴턴소프트.Json 사용

* 마이크로 [소프트.AspNetCore를SignalR설치합니다. . . 프로토콜.뉴턴소프트Json](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet 패키지.

* 클라이언트에서 메서드 호출을 `AddNewtonsoftJsonProtocol` 인스턴스에 `HubConnectionBuilder` 연결합니다.

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* 서버에서 메서드 호출을 `AddNewtonsoftJsonProtocol` 메서드 `AddSignalR` 호출에 `Startup.ConfigureServices`연결합니다.

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>ASP.NET 코어 3.0 MVC 프로젝트에서 뉴턴소프트.Json 사용

* 마이크로 [소프트.AspNetCore.Mvc.뉴턴 소프트 Json](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) 패키지를 설치합니다.

* 를 `Startup.ConfigureServices` 호출하도록 `AddNewtonsoftJson`업데이트합니다.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`새 MVC 서비스 등록 방법과 호환됩니다.

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`설정은 다음 을 호출할 `AddNewtonsoftJson`때 설정할 수 있습니다.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**참고:** 메서드를 `AddNewtonsoftJson` 사용할 수 없는 경우 [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) 패키지를 설치했는지 확인합니다. 일반적인 오류는 [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) 패키지 대신 [뉴턴소프트.Json](https://www.nuget.org/packages/Newtonsoft.Json/) 패키지를 설치하는 것입니다.

## <a name="mvc-service-registration"></a>MVC 서비스 등록

ASP.NET 코어 3.0 내부 `Startup.ConfigureServices`MVC 시나리오를 등록 하기 위한 새로운 옵션을 추가 합니다.

MVC 시나리오와 관련된 세 가지 새로운 `IServiceCollection` 최상위 확장 메서드를 사용할 수 있습니다. 템플릿은 `AddMvc`이러한 새 메서드 대신 을 사용합니다. 그러나 `AddMvc` 이전 릴리스에서와 마찬가지로 계속 작동합니다.

다음 예제에서는 컨트롤러 및 API 관련 기능에 대한 지원을 추가하지만 보기 나 페이지는 지원하지 않습니다. API 템플릿은 다음 코드를 사용합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

다음 예제에서는 컨트롤러, API 관련 기능 및 보기에 대 한 지원을 추가 하지만 페이지. MVC(웹 응용 프로그램) 템플릿은 다음 코드를 사용합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

다음 예제에서는 Razor 페이지에 대한 지원과 최소한의 컨트롤러 지원을 추가합니다. 웹 응용 프로그램 템플릿은 다음 코드를 사용합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

새 메서드를 결합할 수도 있습니다. 다음 예제는 ASP.NET `AddMvc` 코어 2.2에서 호출하는 것과 같습니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>라우팅 시작 코드

앱이 `UseMvc` 호출하거나 `UseSignalR`가능하면 앱을 [Endpoint 라우팅으로](xref:fundamentals/routing) 마이그레이션합니다. 이전 버전의 MVC와의 엔드포인트 라우팅 호환성을 개선하기 위해 ASP.NET 코어 2.2에 도입된 URL 생성변경 사항 중 일부를 되돌렸습니다. 2.2에서 Endpoint 라우팅을 사용하는 데 문제가 있는 경우 다음 을 제외하고 ASP.NET Core 3.0이 개선될 것으로 예상됩니다.

* 앱이 `IRouter` 구현하거나 에서 `Route`상속하는 경우 [DynamicRouteValuesTransformer를](https://github.com/dotnet/AspNetCore.Docs/issues/12997) 대체로 사용합니다.
* 앱이 MVC `RouteData.Routers` 내부에서 직접 액세스하여 URL을 구문 분석하는 경우 [LinkParser.ParsePathByEndpointName을](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*)사용하여 대체할 수 있습니다. 
  * 배관 이름을 가진 경로를 정의합니다.
  * 원하는 `LinkParser.ParsePathByEndpointName` 경로 이름을 사용하고 전달합니다.

끝점 라우팅은 `IRouter`와 동일한 경로 패턴 구문 및 경로 패턴 작성 기능을 지원합니다. 끝점 라우팅이 `IRouteConstraint`지원합니다. 끝점 라우팅은 `[Route]` `[HttpGet]`및 기타 MVC 라우팅 특성을 지원합니다.

대부분의 응용 프로그램의 `Startup` 경우 변경만 필요합니다.

### <a name="migrate-startupconfigure"></a>마이그레이션 시작.구성

일반적인 조언 :

* `UseRouting`를 추가합니다.
* 앱이 `UseStaticFiles`호출하는 `UseStaticFiles` **경우.** `UseRouting`
* 앱에서 `AuthorizePage` 또는 `[Authorize]`와 같은 인증/권한 부여 기능을 `UseAuthentication` `UseAuthorization`사용하는 경우 **다음**에 대해 다음 을 `UseRouting` `UseCors`호출합니다. `UseEndpoints`

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* 을 `UseMvc` `UseSignalR` 바꾸거나 로 합니다. `UseEndpoints`
* 앱에서 와 같은 `[EnableCors]`CORS 시나리오를 사용하는 경우 `UseCors` [CORS를](xref:security/cors) 사용하는 다른 미들웨어(예: `UseCors` `UseAuthentication`이전 `UseAuthorization` `UseEndpoints`및)에 호출합니다.
* 네임스페이스에 대한 문을 바꾸고 `IHostingEnvironment` 추가합니다. `using` <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> `IWebHostEnvironment`
* (네임스페이스)로 `IApplicationLifetime` <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> 바꿉니다.
* (네임스페이스)로 `EnvironmentName` <xref:Microsoft.Extensions.Hosting.Environments> <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> 바꿉니다.

다음 코드는 일반적인 `Startup.Configure` ASP.NET Core 2.2 앱의 예입니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

이전 `Startup.Configure` 코드를 업데이트한 후:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> 대부분의 앱의 경우 `UseAuthentication` `UseAuthorization`에 `UseCors` 대한 호출과 호출 `UseRouting` `UseEndpoints` 사이에 표시되어야 하며 효과적이어야 합니다.

### <a name="health-checks"></a>상태 검사

상태 검사는 제네릭 호스트와의 엔드포인트 라우팅을 사용합니다. `Startup.Configure`에서 엔드포인트 URL 또는 상대 경로를 사용하여 엔드포인트 작성기에 `MapHealthChecks`를 호출합니다.

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

상태 검사 엔드포인트는 다음을 수행할 수 있습니다.

* 허용되는 호스트/포트를 하나 이상 지정합니다.
* 권한 부여가 필요합니다.
* CORS가 필요합니다.

자세한 내용은 <xref:host-and-deploy/health-checks>을 참조하세요.

### <a name="security-middleware-guidance"></a>보안 미들웨어 지침

[미들웨어](xref:fundamentals/middleware/index) 접근 방식을 중심으로 권한 부여 및 CORS 지원이 통합됩니다. 이렇게 하면 이러한 시나리오에서 동일한 미들웨어 및 기능을 사용할 수 있습니다. 이 릴리스에서는 업데이트된 권한 부여 미들웨어가 제공되며, MVC 컨트롤러에서 사용하는 특성을 이해할 수 있도록 CORS 미들웨어가 향상되었습니다.

#### <a name="cors"></a>CORS

이전에는 CORS를 구성하기 어려울 수 있었습니다. 미들웨어는 일부 사용 사례에서 사용하도록 제공되었지만 MVC 필터는 다른 사용 사례에서 미들웨어 **없이** 사용하도록 의도되었습니다. ASP.NET 코어 3.0에서는 CORS가 필요한 모든 앱이 엔드포인트 라우팅과 함께 CORS 미들웨어를 사용하는 것이 좋습니다. `UseCors`기본 정책과 함께 제공될 `[EnableCors]` 수 `[DisableCors]` 있으며, 특성을 사용하여 필요한 경우 기본 정책을 재정의할 수 있습니다.

다음 예제에서,

* CORS는 명명된 정책이 있는 `default` 모든 끝점에 대해 활성화됩니다.
* 클래스는 `MyController` 특성으로 CORS를 사용하지 않도록 설정합니다. `[DisableCors]`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>권한 부여

이전 버전의 ASP.NET Core에서는 특성을 `[Authorize]` 통해 권한 부여 지원이 제공되었습니다. 권한 부여 미들웨어를 사용할 수 없습니다. ASP.NET 코어 3.0에서는 권한 부여 미들웨어가 필요합니다. ASP.NET 코어 인증 미들웨어 ()`UseAuthorization`바로 `UseAuthentication`그 다음에 배치하는 것이 좋습니다. 권한 부여 미들웨어는 재정의할 수 있는 기본 정책으로 구성할 수도 있습니다.

ASP.NET Core 3.0 이상에서는 `UseAuthorization` 에서 `Startup.Configure`호출되며 `HomeController` 다음에는 로그인한 사용자가 필요합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

끝점 라우팅을 사용하는 경우 권한 부여 `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` 미들웨어를 구성하고 대신 사용하지 않도록 하는 것이 좋습니다.  앱이 MVC에서 전역 필터로 를 `AuthorizeFilter` 사용하는 경우 코드를 리팩터링하여 `AddAuthorization`에 대한 정책을 제공하는 것이 좋습니다.

처음에는 `DefaultPolicy` 인증이 필요하도록 구성되므로 추가 구성이 필요하지 않습니다. 다음 예제에서는 MVC 끝점이 로 `RequireAuthorization` 표시되므로 모든 요청은 `DefaultPolicy`을 기반으로 권한이 부여되어야 합니다. 그러나 다음을 수행하여 사용자가 앱에 로그인하지 않고도 액세스할 `HomeController` 수 있습니다. `[AllowAnonymous]`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>특정 끝점에 대한 권한 부여

특정 엔드포인트 클래스에 대해 권한 부여를 구성할 수도 있습니다. 다음 코드는 전역을 권한 부여가 필요한 특정 정책을 `AuthorizeFilter` 사용하여 전역을 앱으로 구성한 MVC 앱을 변환하는 예입니다.

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

정책을 사용자 지정할 수도 있습니다. `DefaultPolicy` 인증이 필요하도록 구성됩니다.

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

또는 `[Authorize]` `FallbackPolicy`을 구성하지 않고 또는 `RequireAuthorization` 구성하여 권한 부여가 필요하도록 모든 끝점을 구성할 수 있습니다. 의 `FallbackPolicy` 다른 `DefaultPolicy`. 은 `DefaultPolicy` 다른 정책이 `[Authorize]` `RequireAuthorization`설정되지 `FallbackPolicy` 않은 경우 트리거되는 동안 또는 에 의해 트리거됩니다. `FallbackPolicy`처음에는 승인 없이 요청을 허용하도록 구성됩니다.

다음 예제는 앞의 `DefaultPolicy` 예제와 동일하지만 `FallbackPolicy` 지정된 경우를 `[AllowAnonymous]` 제외한 모든 끝점에 대해 항상 인증을 요구하는 데 사용합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

미들웨어에 의한 권한 부여는 권한 부여에 대한 구체적인 지식이 없는 프레임워크 없이 작동합니다. 예를 들어 [상태 확인에는](xref:host-and-deploy/health-checks) 권한 부여에 대한 구체적인 지식이 없지만 상태 확인에는 미들웨어에서 구성 가능한 권한 부여 정책이 적용될 수 있습니다.

또한 각 끝점은 권한 부여 요구 사항을 사용자 지정할 수 있습니다. 다음 예제에서는 `UseAuthorization` `DefaultPolicy`을 사용 하 고 `/healthz` 권한 부여를 `admin` 처리 하지만 상태 확인 끝점에서 사용자가 필요 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

일부 시나리오에 대해 보호가 구현됩니다. 엔드포인트 미들웨어는 미들웨어 누락으로 인해 권한 부여 또는 CORS 정책을 건너뛰는 경우 예외를 throw합니다. 잘못된 구성에 대한 추가 피드백을 제공하기 위한 분석기 지원이 진행 중입니다.

#### <a name="custom-authorization-handlers"></a>사용자 지정 권한 부여 처리기

앱에서 사용자 지정 [권한 부여 처리기를](xref:security/authorization/policies#authorization-handlers)사용하는 경우 끝점 라우팅은 MVC와 다른 리소스 형식을 처리기에 전달합니다. 권한 부여 처리기 컨텍스트 리소스가 <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> 형식(MVC [필터에서 제공하는](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)리소스 유형)이 될 것으로 예상되는 <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> 처리기는 형식의 리소스(끝점 라우팅에 의해 권한 부여 처리기에 부여된 리소스 유형)를 처리하도록 업데이트해야 합니다.

MVC는 `AuthorizationFilterContext` 여전히 리소스를 사용하므로 앱에서 엔드포인트 라우팅 권한 부여와 함께 MVC 권한 부여 필터를 사용하는 경우 두 가지 유형의 리소스를 모두 처리해야 할 수 있습니다.

### SignalR

허브 SignalR 매핑은 이제 내부에서 `UseEndpoints`수행됩니다.

각 허브를 `MapHub`으로 매핑합니다. 이전 버전과 마찬가지로 각 허브는 명시적으로 나열됩니다.

다음 예제에서는 `ChatHub` SignalR 허브에 대한 지원이 추가됩니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

클라이언트에서 메시지 크기 제한을 제어하기 위한 새로운 옵션이 있습니다. 예를 들어 `Startup.ConfigureServices`에서는 다음과 같습니다.

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

ASP.NET 코어 2.2에서는 설정할 `TransportMaxBufferSize` 수 있으며 최대 메시지 크기를 효과적으로 제어할 수 있습니다. ASP.NET 코어 3.0에서 이 옵션은 이제 배압이 관찰되기 전에 최대 크기만 제어합니다.

### <a name="mvc-controllers"></a>MVC 컨트롤러

컨트롤러매핑은 이제 내부에서 `UseEndpoints`수행됩니다.

앱에서 특성 라우팅을 사용하는 경우 추가합니다. `MapControllers` 라우팅에는 ASP.NET Core 3.0 이상의 많은 프레임워크에 대한 지원이 포함되어 있기 때문에 특성 라우팅 컨트롤러를 추가하는 것은 옵트인입니다.

다음 내용을

* `MapRoute`(`MapControllerRoute` 사용)
* `MapAreaRoute`(`MapAreaControllerRoute` 사용)

라우팅에는 MVC 이상의 지원이 포함되어 있기 때문에 이러한 메서드가 수행하는 작업을 명확하게 명시하도록 용어가 변경되었습니다. 기존 경로와 `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` 같은 경로는 추가되는 순서대로 적용됩니다. 보다 구체적인 경로(예: 영역의 경로)를 먼저 배치합니다.

다음 예제에서,

* `MapControllers`속성 라우팅 컨트롤러에 대한 지원을 추가합니다.
* `MapAreaControllerRoute`영역에서 컨트롤러에 대한 기존 경로를 추가합니다.
* `MapControllerRoute`컨트롤러에 대한 기존 경로를 추가합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>컨트롤러 작업 이름에서 비동기 접미사 제거

코어 3.0ASP.NET ASP.NET 코어 MVC는 `Async` 컨트롤러 작업 이름에서 접미사를 제거합니다. 라우팅 및 링크 생성모두 이 새 기본값의 영향을 받습니다. 다음은 그 예입니다.

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

ASP.NET 코어 3.0 이전:

* 위의 작업은 *제품/ListAsync* 경로에서 액세스할 수 있습니다.
* 링크 생성은 접미사를 지정해야 `Async` 합니다. 다음은 그 예입니다.

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

ASP.NET 코어 3.0:

* 위의 작업은 *제품/목록* 경로에서 액세스할 수 있습니다.
* 링크 생성은 접미사를 `Async` 지정할 필요가 없습니다. 다음은 그 예입니다.

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

이 변경 사항은 [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) 특성을 사용하여 지정된 이름에는 영향을 주지 않습니다. 다음 코드에서 `Startup.ConfigureServices`기본 동작을 사용하지 않도록 선택할 수 있습니다.

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>링크 생성 변경 사항

[이전 버전의 라우팅과의 차이점에](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)대한 설명서에서 설명한 대로 `Url.Link` 링크 생성에 몇 가지 차이점이 있습니다(예: API 사용 및 유사 API 사용). 여기에는 다음이 포함됩니다.

* 기본적으로 끝점 라우팅을 사용하는 경우 생성된 URI에서 경로 매개 변수의 대/소문자를 반드시 보존할 필요는 없습니다. 이 동작은 인터페이스를 `IOutboundParameterTransformer` 사용하여 제어할 수 있습니다.
* 잘못된 경로(존재하지 않는 컨트롤러/작업 또는 페이지)에 대한 URI를 생성하면 잘못된 URI를 생성하는 대신 끝점 라우팅 아래에 빈 문자열이 생성됩니다.
* 주변 값(현재 컨텍스트의 경로 매개변수)은 끝점 라우팅이 있는 링크 생성에 자동으로 사용되지 않습니다. 이전에는 다른 작업(또는 페이지)에 대한 링크를 생성할 때 지정되지 않은 경로 값이 *현재* 라우트 주변 값에서 유추됩니다. 끝점 라우팅을 사용하는 경우 링크 생성 중에 모든 경로 매개변수를 명시적으로 지정해야 합니다.

### <a name="razor-pages"></a>Razor 페이지

면도기 페이지 매핑은 `UseEndpoints`이제 내부에서 이루어집니다.

앱에서 Razor 페이지를 사용하는 경우 추가합니다. `MapRazorPages` 엔드포인트 라우팅에는 많은 프레임워크에 대한 지원이 포함되어 있기 때문에 Razor 페이지를 추가하는 것은 이제 옵트인입니다.

다음 `Startup.Configure` 방법에서는 `MapRazorPages` Razor 페이지에 대한 지원을 추가합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>엔드포인트 라우팅 없이 MVC 사용

코어 3.0을 통해 `UseMvc` 또는 `UseMvcWithDefaultRoute` ASP.NET MVC를 사용하려면 내부에 `Startup.ConfigureServices`명시적 옵트인이 필요합니다. MVC는 초기화 중에 권한 부여 및 CORS 미들웨어에 의존할 수 있는지 여부를 알고 있어야 하기 때문에 이 필요합니다. 앱이 지원되지 않는 구성을 사용하려고 시도하는 경우 경고하는 분석기가 제공됩니다.

앱에 레거시 `IRouter` 지원이 필요한 `EnableEndpointRouting` 경우 다음 방법 `Startup.ConfigureServices`중 에서 다음 방법을 사용하여 사용하지 않도록 설정합니다.

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>상태 검사

상태 확인은 Endpoint 라우팅을 사용하여 *라우터 웨어로* 사용할 수 있습니다.

끝점 라우팅을 사용하여 상태 확인을 사용하도록 추가합니다. `MapHealthChecks` 메서드는 `MapHealthChecks` 와 유사한 인수를 `UseHealthChecks`허용합니다. Over를 `UseHealthChecks` 사용하면 `MapHealthChecks` 권한 부여를 적용하고 일치 정책에 대한 보다 세밀한 제어를 할 수 있다는 장점이 있습니다.

다음 예제에서는 `MapHealthChecks` 다음 의 상태 확인 끝점에 대 한 호출 됩니다. `/healthz`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>호스트빌더가 웹호스트빌더를 대체합니다.

ASP.NET 코어 3.0 템플릿은 [일반 호스트를](xref:fundamentals/host/generic-host)사용합니다. 이전 버전에서 [웹 호스트를](xref:fundamentals/host/web-host)사용했습니다. 다음 코드는 ASP.NET Core 3.0 `Program` 템플릿 생성 클래스를 보여 주며 다음과 같은 클래스를 보여 주며 다음과 같은 코드입니다.

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

다음 코드는 ASP.NET Core 2.2 `Program` 템플릿 생성 클래스를 보여 주며 다음과 같은 코드입니다.

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>3.0에 남아 있으며 이전 코드 `webBuilder` 샘플에서 볼 수 있는 형식입니다. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>이후 릴리스에서 더 이상 사용되지 않으며 `HostBuilder`로 대체됩니다.

에서 `WebHostBuilder` `HostBuilder` 가장 중요한 변화는 [종속성 주입 (DI)입니다.](xref:fundamentals/dependency-injection) 을 `HostBuilder`사용할 때다음을 생성자로만 삽입할 `Startup`수 있습니다.

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

`HostBuilder` DI 제약 조건:

* DI 컨테이너를 한 번만 빌드할 수 있도록 합니다.
* 단일 톤의 여러 인스턴스를 해결하는 것과 같은 결과 개체 수명 문제를 방지합니다.

자세한 내용은 [ASP.NET 코어 3에서 시작 서비스 주입 방지를](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/)참조하십시오.

## <a name="addauthorization-moved-to-a-different-assembly"></a>추가 권한 부여가 다른 어셈블리로 이동했습니다.

ASP.NET 코어 2.2 `AddAuthorization` 및 *Microsoft.AspNetCore.Authorization.dll에서*낮은 방법 :

* 이름이 바뀌었습니다. `AddAuthorizationCore`
* *Microsoft.AspNetCore.권한 부여.Policy.dll로*이동되었습니다.

*Microsoft.AspNetCore.Authorization.dll* 및 *Microsoft.AspNetCore.Authorization.Authorization.policy.dll을* 모두 사용하는 앱은 영향을 받지 않습니다.

*Microsoft.AspNetCore.Authorization.Policy.dll을* 사용하지 않는 앱은 다음 중 하나를 수행해야 합니다.

* *Microsoft.AspNetCore.Authorization.Policy.dll에*대한 참조를 추가합니다. 이 방법은 대부분의 앱에서 작동하며 필요한 모든 것입니다.
* 사용으로 전환`AddAuthorizationCore`

자세한 내용은 [ `AddAuthorization(o =>`다른 어셈블리 #386 )의 주요 변경 을](https://github.com/aspnet/Announcements/issues/386)참조하십시오.

## <a name="identity-ui"></a>아이덴티티 UI

ASP.NET 코어 3.0에 대한 ID UI 업데이트:

* [Microsoft.AspNetCore.Identity.UI에](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI)패키지 참조를 추가합니다.
* Razor 페이지를 사용하지 않는 앱은 `MapRazorPages`다음 을 호출해야 합니다. 이 문서의 [면도기 페이지를](#razor-pages) 참조하십시오.
* 부트스트랩 4는 기본 UI 프레임워크입니다. 기본값을 `IdentityUIFrameworkVersion` 변경하려면 프로젝트 속성을 설정합니다. 자세한 내용은 [이 GitHub 공지를](https://github.com/aspnet/Announcements/issues/380)참조하십시오.

## SignalR

자바 SignalR 스크립트 클라이언트가 `@aspnet/signalr` `@microsoft/signalr`에서 변경되었습니다. 이러한 변경에 대응하려면 *package.json* 파일, `require` 명령문 및 ECMAScript `import` 문의 참조를 변경합니다.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Json은 기본 프로토콜입니다.

`System.Text.Json`이제 클라이언트와 서버 모두에서 사용되는 기본 Hub 프로토콜입니다.

에서 `Startup.ConfigureServices`직렬화기 옵션을 설정하려면 호출합니다. `AddJsonProtocol`

**서버:**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**클라이언트:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>뉴턴소프트.Json으로 전환

[System.Text.Json에서 지원되지 않는 Newtonsoft.Json의 기능을](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)사용하는 경우 `Newtonsoft.Json`로 다시 전환할 수 있습니다. 이 문서의 ASP.NET [코어 3.0 SignalR 프로젝트에서 Newtonsoft.Json 사용을](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) 참조하십시오.

## <a name="redis-distributed-caches"></a>분산 캐시 재배포

[Microsoft.Extensions.Caching.Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) 패키지는 ASP.NET 코어 3.0 이상 앱에는 사용할 수 없습니다. 패키지 참조를 [Microsoft.Extension.Caching.StackExchangeRedis로](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis)바꿉니다. 자세한 내용은 <xref:performance/caching/distributed>을 참조하세요.

## <a name="opt-in-to-runtime-compilation"></a>런타임 컴파일에 옵트인

ASP.NET Core 3.0 이전에는 런타임 뷰 컴파일이 프레임워크의 암시적 기능이었습니다. 런타임 컴파일은 뷰의 빌드 시간 컴파일을 보완합니다. 전체 앱을 다시 빌드하지 않고도 파일이 수정될 때 프레임워크에서 Razor 보기 및*페이지(.cshtml* 파일)를 컴파일할 수 있습니다. 이 기능은 IDE에서 빠르게 편집하고 브라우저를 새로 고쳐 변경 내용을 확인하는 시나리오를 지원합니다.

ASP.NET 코어 3.0에서 런타임 컴파일은 옵트인 시나리오입니다. 빌드 시간 컴파일은 기본적으로 활성화된 뷰 컴파일을 위한 유일한 메커니즘입니다. 런타임은 Visual Studio 또는 [도트넷 보기(dotnet-watch)를](xref:tutorials/dotnet-watch) 사용하여 *.cshtml* 파일의 변경 내용을 감지할 때 프로젝트를 다시 빌드합니다. Visual Studio에서 실행 중인 프로젝트의 *.cs,* *.cshtml*또는 *.razor* 파일을 변경하지만 디버깅(F5)은 아니지만 프로젝트의 재컴파일을 트리거합니다.<kbd>Ctrl+F5</kbd><kbd>F5</kbd>

ASP.NET Core 3.0 프로젝트에서 런타임 컴파일을 사용하려면 다음을 수행하십시오.

1. [Microsoft.AspNetCore.Mvc.Razor.Runtime컴파일](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) NuGet 패키지를 설치합니다.
1. 호출 `Startup.ConfigureServices` `AddRazorRuntimeCompilation`업데이트 :

    ASP.NET 코어 MVC의 경우 다음 코드를 사용합니다.

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    ASP.NET 코어 면도기 페이지의 경우 다음 코드를 사용합니다.
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
샘플에서는 https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation 개발 환경에서 런타임 컴파일을 조건부로 사용하도록 설정하는 예제를 보여 줍니다.

Razor 파일 컴파일에 대한 자세한 <xref:mvc/views/view-compilation>내용은 을 참조하십시오.

## <a name="migrate-libraries-via-multi-targeting"></a>다중 타겟팅을 통해 라이브러리 마이그레이션

라이브러리는 종종 ASP.NET 코어의 여러 버전을 지원해야 합니다. 이전 버전의 ASP.NET 코어에 대해 컴파일된 대부분의 라이브러리는 문제 없이 계속 작업해야 합니다. 다음 조건은 앱을 교차 컴파일해야 합니다.

* 라이브러리는 이진 주요 변경 이있는 기능을 [기반으로합니다.](#breaking-api-changes)
* 라이브러리는 ASP.NET 코어 3.0의 새로운 기능을 활용하려고 합니다. 

다음은 그 예입니다.

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

ASP.NET `#ifdefs` 코어 3.0 특정 API를 활성화하는 데 사용합니다.

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

클래스 라이브러리에서 ASP.NET 코어 API 사용에 대한 <xref:fundamentals/target-aspnetcore>자세한 내용은 을 참조하십시오.

## <a name="miscellaneous-changes"></a>기타 변경 내용

.NET Core 3.0 이상의 유효성 검사 시스템은 Null을 허용하지 않는 매개 변수 또는 바인딩된 속성을 `[Required]` 특성을 포함한 것처럼 처리합니다. 자세한 내용은 [[필수] 특성을](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute)참조하십시오.

### <a name="publish"></a>게시

프로젝트 디렉터리에서 *Bin* 및 *obj* 폴더를 삭제합니다.

## <a name="testserver"></a>TestServer

[일반 호스트에서](xref:fundamentals/host/web-host)직접 사용하는 <xref:Microsoft.AspNetCore.TestHost.TestServer> 앱의 `TestServer` 경우 <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> 에서 <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>를 만듭니다.

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>API 변경 사항 주요 사항

주요 변경 사항 검토:

* [ASP.NET 코어 3.0 릴리스의 주요 변경 사항 전체 목록](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [위조, CORS, 진단, MVC 및 라우팅에서 API 변경 내용 을 깨는.](https://github.com/aspnet/Announcements/issues/387) 이 목록에는 호환성 스위치에 대한 주요 변경 내용이 포함되어 있습니다.
* .NET 코어, ASP.NET 코어 및 엔터티 프레임워크 코어에서 2.2-3.0 주요 변경 사항에 대한 요약은 [버전 2.2에서 3.0으로의 마이그레이션에 대한 주요 변경 내용을](/dotnet/core/compatibility/2.2-3.0)참조하십시오.

## <a name="net-core-30-on-azure-app-service"></a>Azure 앱 서비스의 .NET 코어 3.0

.NET Core에서 Azure 앱 서비스에 대한 롤아웃에 대한 진행 상황은 앱 서비스 웹 사이트의 공식 [.NET Core를](https://aspnetcoreon.azurewebsites.net/) 참조하십시오. Azure 앱 서비스에서 .NET Core 3.0을 사용할 수 있는 때까지 [Azure 앱 서비스에 ASP.NET 코어 미리 보기 배포](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service)릴리스의 지침을 따릅니다.
